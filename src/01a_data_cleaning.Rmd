---
title: "01a_data_cleaning"
author: "Jacob Beck"
date: "`r Sys.Date()`"
output: distill::distill_article
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

# Load packages

```{r message=FALSE, warning=FALSE}
library(tidyverse)
```

Preprocessing steps

-   infer number of cols
-   assign col type to weird columns

```{r}
col_number_df <- readxl::read_xlsx("../data/processed/appended_data.xlsx")

col_count <- ncol(col_number_df)

# Some page numbers have special characters, e.g. *67 => import page used and page corrected column as string types
col_types <- rep("guess", col_count)
col_types[2] <- "text"
col_types[14] <- "text"
```

# Load and preprocess Data

-   Load data
-   Rename variables

```{r warning=FALSE}
raw_data <- readxl::read_xlsx("../data/processed/appended_data.xlsx", col_types = col_types)

df <- raw_data %>% rename(
  page_used = `Page used`,
  llm_scope = `LLM Year`, # column year and scope swapped in original excel by mistake
  llm_value = `LLM value`,
  llm_unit = `LLM unit`,
  llm_year = `LLM Scope`, # column year and scope swapped in original excel by mistake
  value_correct = `Value correct (Yes/No)`,
  corrected_value = `Value corrected
(fill in if necessary)`,
value_reasoning = `Value Reasoning
(select if necessary, if multiple apply choose first)`,
unit_correct = `Unit correct (Yes/No)`,
corrected_unit = `Unit corrected\n(fill in if necessary)`,
    unit_reasoning = `Unit Reasoning\n(select if necessary, if multiple apply choose first)`,
    page_correct = `Page correct (Yes/No)`,
    corrected_page = `Page corrected\n(fill in if necessary)`,
    reporting_type = `Reporting Type (Table/Graphic/\nText/â€¦) from PDF`,
    metric_name = `Emission Metric Name from PDF`,
    comment = `Comment\n(if helpful)`,
    record_expert_needed = `Record needs expert adjudication (Yes/No)`,
    exp_corrected_value = `Expert Value corrected`,
    exp_corrected_unit = `Expert unit corrected`,
    exp_corrected_page = `Expert page corrected`,
    exp_comment = `Expert Comment`,
    exp_problem = `Expert cannot determine correct value, unit or page`,
    PageTextsToLLM = `page_texts_to_llm`,
    TextResponseFromLLM = `text_response_from_llm`,
    report_name = `Report Name:`,
    pages_searched = `Pages searched:`,
    annotator_ID = `Annotator ID:`,
    reporting_standards = `Reporting standards:`,
    company_boundaries = `Handling company boundaries:`,
    document_expert_needed = `Document needs expert adjudication:`,
    document_comment = `Document comment:`,
    expert_ID = `Expert ID:`
)
```

# Clean data

## Handle missing annotator ID

```{r}
df %>% filter(is.na(annotator_ID)) %>%
  select(report_name, annotator_ID) %>%
  distinct(report_name)

```

=\> 4 reports have a missing annotator ID

Manually retrieved annotator IDs from the original data:

| report_name   | annotator_ID |
|---------------|--------------|
| daimler 2020  | 6            |
| kitz 2019     | 8            |
| lundin 2021   | 6            |
| varta 2021    | 6            |

Put in the corrected annotator IDs

```{r}
df1 <- df %>%
  mutate(
    annotator_ID = ifelse(report_name == "kitz corp_2019_report.pdf" & is.na(annotator_ID), 8, annotator_ID),
    annotator_ID = ifelse(report_name == "Daimler_2020_report.pdf" & is.na(annotator_ID), 6, annotator_ID),
    annotator_ID = ifelse(report_name == "varta ag_2021_report.pdf" & is.na(annotator_ID), 6, annotator_ID),
    annotator_ID = ifelse(report_name == "lundin gold inc_2021_report.pdf" & is.na(annotator_ID), 6, annotator_ID)
    )

table(df1$annotator_ID) # check that there are more or less the same number of rums for every annotator
```

## Handle the rows with row ID "x"

A non-x row is a page-year-scope combination. For the x-rows, transform the ID to a similar variable by concatenating page, year and scope.

```{r}
df2 <- df1 %>%
  mutate(ID = ifelse(ID == "x",paste0("x_", corrected_page,"_", llm_year,"_", llm_scope),ID))
```

## Handle wrong formatting in corrected_value  

Inspect all the values
```{r}
df2 %>% select(corrected_value) %>% distinct()
```

While llm_value is a numeric column, corrected_value is a character column. We want to transform corrected_value to numeric, but this might create problems if values inserted by annotators have wrong format.

- Annotators sometimes use ',' in 6-digit numbers ==> remove ','
- Annotators sometimes use '.' in 6-digit numbers to separate thousands ==> remove '.'
- value 209,034.43 4 seems to be a typing error ==> remove last character
- Instead of leaving the cell empty, the annotators sometimes wrote "-" ==> set to ""

```{r}
pattern <- "^\\d{3}\\.\\d{3}$" # e.g. 209.034
df3 <- df2 %>% mutate(corrected_value = str_replace_all(corrected_value, "[-,]", ""),
                      corrected_value = ifelse(corrected_value == "209034.43 4", "209034.43", corrected_value),
                      corrected_value = str_replace_all(corrected_value, pattern, str_replace_all(corrected_value, "\\.", "")),)
```

Now try conversion to numeric again
```{r}
df3$corrected_value <- as.numeric(df3$corrected_value)
```

## Handle falsely set reporting_type

If the value_correct is "No" and corrected_value is NA, the reporting_type and metric_name should be NA because the latter refer to the true value

```{r}
df3 %>% filter(value_correct == "No" & is.na(corrected_value) & (!is.na(reporting_type) | !is.na(metric_name)))
```

```{r}
df4 <- df3 %>% mutate(
  reporting_type = ifelse(value_correct == "No" & is.na(corrected_value), NA, reporting_type), 
  metric_name = ifelse(value_correct == "No" & is.na(corrected_value), NA, metric_name))
```

## Handle duplicate rows which differ only in reporting_type or metric_name reported by two annotators

```{r}
df_output_format <- df4 %>% 
  select(ID, report_name, llm_scope, llm_year, llm_value, llm_unit, page_used, metric_name, reporting_type) %>% distinct()

similar_rows_by_reporting_type <- df_output_format %>%
  group_by(across(-reporting_type)) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  arrange(ID)

similar_rows_by_metric_name <- df_output_format %>%
  group_by(across(-metric_name)) %>%
  filter(n() > 1) %>%
  ungroup() %>%
  arrange(ID)
```

Get entries annotated by annotators

```{r}
similar_rows_by_reporting_type <- left_join(similar_rows_by_reporting_type, df3, by = c("ID", "report_name", "llm_scope", "llm_year", "llm_value", "llm_unit", "page_used", "metric_name", "reporting_type"))

similar_rows_by_metric_name <- left_join(similar_rows_by_metric_name, df3, by = c("ID", "report_name", "llm_scope", "llm_year", "llm_value", "llm_unit", "page_used", "metric_name", "reporting_type"))
```

Remove similar_rows_by_reporting_type and similar_rows_by_metric_name from df3 to add corrected rows later again

```{r}
df5 <- df4 %>% anti_join(similar_rows_by_reporting_type, by = c("ID", "report_name", "llm_scope", "llm_year", "llm_value", "llm_unit", "page_used", "metric_name", "reporting_type")) %>%
  anti_join(similar_rows_by_metric_name, by = c("ID", "report_name", "llm_scope", "llm_year", "llm_value", "llm_unit", "page_used", "metric_name", "reporting_type"))
```

Manually inspect the rows of similar_rows_by_reporting_type:

Annotators set different reporting_type ==\> **to be inspected together**

```{r}
similar_rows_by_reporting_type
```

Add rows in similar_rows_by_reporting_type back to main dataframe

```{r}
df6 <- df5 %>% bind_rows(similar_rows_by_reporting_type)
```

Manually inspect the rows of similar_rows_by_metric_name:

```{r}
similar_rows_by_metric_name <- similar_rows_by_metric_name %>% arrange(report_name, ID)
```

Manual inspection:

1.  Group: metric_name is missing, but all other values exact duplicate of other row ==\> use fill to copy metric_name where reporting_type set

```{r}
similar_rows_by_metric_name <- similar_rows_by_metric_name %>% group_by(ID, report_name, llm_scope, llm_year, llm_value, llm_unit, page_used, reporting_type, value_correct) %>% fill(metric_name, .direction = "downup")
```

```{r}
similar_rows_by_metric_name %>% filter(is.na(metric_name) | is.na(reporting_type))
```

Manual correction:

-   sps commerce inc_2020_report.pdf: For corrected_value NOT NA reporting_type should NOT be NA ==\> set to For corrected_value is NA metric_name should be NA

```{r}
similar_rows_by_metric_name <- similar_rows_by_metric_name %>% mutate(
  metric_name = ifelse(report_name == "sps commerce inc_2020_report.pdf" & is.na(corrected_value), NA, metric_name),
  reporting_type = ifelse(report_name == "sps commerce inc_2020_report.pdf" & !is.na(corrected_value) & is.na(reporting_type), "Table", reporting_type)
)
```

2.  Group: differ only in metric_name

```{r}
similar_rows_by_metric_name %>% group_by(ID, report_name, llm_scope, llm_year, llm_value, llm_unit, page_used, reporting_type) %>% 
  filter(n_distinct(metric_name) > 1) %>% 
  ungroup()
```

Observations:

-   slight differences, e.g. "\n" included in one metric_name, but not the other ==\> normalisation needed

-   some annotators also report unit in metric_name

-   various nomenclature for scope 1, 2, 3

-   interesting for error analysis

Replace changed rows in similar_rows_by_metric_name in df5

```{r}
df7 <- df6 %>% bind_rows(similar_rows_by_metric_name)
```


## Handle differences in corrected value and corrected page between annotators

While creating the gold standard data set, we noticed a couple of mistakes in the annotations which will not be corrected by expert annotation. This concerns rows where both annotators agree on the value correct column, but they disagree on the corrected value or the corrected page. In the following, we want to correct these rows in the data set.

We first identify the rows which are concerned by this issue.

```{r}
source("../src/pivot.R")
```

```{r}
# Variable list can be extended any time
pivot_vars <- c("value_correct", "corrected_value", "unit_correct", "corrected_unit", "page_correct", "corrected_page")
pivot_combined <- pivot_w_split(df7, pivot_vars)
```

Create agreement columns for all variables
```{r}
vars_for_agreement <- c("value_correct", "corrected_value", "unit_correct", "corrected_unit", "page_correct", "corrected_page")

for (var in vars_for_agreement) {
    pivot_combined <- agreement_func(pivot_combined, var)
}
```

Further we want to normalize the unit:

Load normalization dictionary
```{r}
normalization_dict <- read.csv("../data/processed/unit_normalization.csv")
```

Merge normalized units to dataset
```{r}
pivot_combined <- pivot_combined %>% 
  mutate(normalized_corrected_unit_1 = ifelse(!is.na(corrected_unit_1), normalization_dict$normalized_unit[match(corrected_unit_1, normalization_dict$unit)], corrected_unit_1),
         normalized_corrected_unit_2 = ifelse(!is.na(corrected_unit_2), normalization_dict$normalized_unit[match(corrected_unit_2, normalization_dict$unit)], corrected_unit_2))

pivot_combined <- agreement_func(pivot_combined, "normalized_corrected_unit")
```

Identify problematic rows where annotators agree on the value correct column, but disagree on the corrected value or the corrected page or the normalized corrected unit
```{r}
pivot_combined <- pivot_combined %>% mutate(agreement_value_and_unit = agreement_value_correct & agreement_unit_correct)
problematic_rows <- pivot_combined %>% group_by(report_name) %>% filter(all(agreement_value_and_unit == T) & (!agreement_corrected_value | !agreement_corrected_page | !agreement_normalized_corrected_unit))
```

Manual inspection of problematic rows
- disagreement on corrected value: 
    - inchcape plc_2022_report.pdf (annotator 1 found values, annotator 2 did not) ==> No value for 2019 in report 
    ==> annotator 2 is right
    ==> set values of annotator 1 to values of annotator 2
    - apollo commercial real estate fina_2019_report.pdf (annotator 1 found values, annotator 2 did not) 
    ==> annotator 1 is right
    ==> set values of annotator 2 to values of annotator 1
    - americold realty inc_2022_report.pdf (probably a typo: 72314 vs. 72134)	
    ==> annotator 2 is right
    ==> set value of annotator 1 to value of annotator 2
- disagreement on corrected page:
    - freni brembo_2018_report.pdf (Annotator 2: 127 because Page correct: No, Annotator 1: NA because Page correct: Yes) 
    ==> Annotator 1 is right (127 is page number on page pdf)
    ==> Set corrected page of annotator 2 to corrected page of annotator 1
    - evolution mining ltd_2020_report.pdf (page 42 vs. 44) 
    ==> page 44 is correct 
    ==> annotator 2 is right
    ==> set corrected page of annotator 1 to corrected page of annotator 2

Manual correction of problematic rows
```{r}
problematic_rows <- problematic_rows %>% mutate(
  corrected_value_1 = ifelse(report_name == "inchcape plc_2022_report.pdf", corrected_value_2, corrected_value_1),
  corrected_unit_1 = ifelse(report_name == "inchcape plc_2022_report.pdf", corrected_unit_2, corrected_unit_1),
  page_correct_1 = ifelse(report_name == "inchcape plc_2022_report.pdf", page_correct_2, page_correct_1),
  corrected_value_2 = ifelse(report_name == "apollo commercial real estate fina_2019_report.pdf", corrected_value_1, corrected_value_2),
  corrected_unit_2 = ifelse(report_name == "apollo commercial real estate fina_2019_report.pdf", corrected_unit_1, corrected_unit_2),
  corrected_page_2 = ifelse(report_name == "apollo commercial real estate fina_2019_report.pdf", corrected_page_1, corrected_page_2),
  corrected_value_1 = ifelse(report_name == "americold realty inc_2022_report.pdf", corrected_value_2, corrected_value_1),
  page_correct_2 = ifelse(report_name == "freni brembo_2018_report.pdf", page_correct_1, page_correct_2),
  corrected_page_2 = ifelse(report_name == "freni brembo_2018_report.pdf", corrected_page_1, corrected_page_2),
  corrected_page_1 = ifelse(report_name == "evolution mining ltd_2020_report.pdf", corrected_page_2, corrected_page_1)
)
```

Reverse the pivot to replace the corrected rows in the main dataframe
```{r}
pivot_corrected <- problematic_rows %>% select(-starts_with("agreement"), -starts_with("normalized")) %>%
  group_by(report_name, ID, page_used, llm_year, llm_scope, llm_value, llm_unit) %>%
  pivot_longer(cols = -c(report_name, ID, page_used, llm_year, llm_scope, llm_value, llm_unit), names_to = c(".value", "set"), names_pattern = "(.+)_(.+)") %>% select(-set)
```

Join corrected rows back to main dataframe
```{r}
extra_columns_corrections <- df7 %>% right_join(pivot_corrected, by = c("report_name", "ID", "page_used", "llm_year", "llm_scope", "llm_value", "llm_unit", "annotator_ID")) %>% select(-ends_with(".x"), -ends_with(".y"))

pivot_corrected <- pivot_corrected %>% left_join(extra_columns_corrections, by = c("report_name", "ID", "page_used", "llm_year", "llm_scope", "llm_value", "llm_unit", "annotator_ID"))

df8 <- df7 %>% anti_join(pivot_corrected, by = c("report_name", "ID", "page_used", "llm_year", "llm_scope", "llm_value", "llm_unit", "annotator_ID")) %>% bind_rows(pivot_corrected)
```

## Handle annotation mistakes
If value_correct == "Yes", corrected_value should be NA
If corrected_value is not NA, value_correct should be "No"
Equivalently for unit and page

For value:
- Is value_correct NA for corrected_value not NA?

```{r}
df8 %>% filter(is.na(value_correct) & !is.na(corrected_value))

```
Set value_correct to "No"
```{r}
df9 <- df8 %>% mutate(value_correct = ifelse(is.na(value_correct) & !is.na(corrected_value), "No", value_correct))
```
- Is value correct == "Yes" and corrected_value not NA?
```{r}
df9 %>% filter(value_correct == "Yes" & !is.na(corrected_value))
```

For unit:
- Is value_correct NA for corrected_value not NA?
```{r}
df9 %>% filter(is.na(unit_correct) & !is.na(corrected_unit))
```
```{r}
df10 <- df9 %>% mutate(unit_correct = ifelse(is.na(unit_correct) & !is.na(corrected_unit), "No", unit_correct))
```

- Is unit_correct set to "Yes" and corrected_unit not NA?
```{r}
df10 %>% filter(unit_correct == "Yes" & !is.na(corrected_unit))
```

For page:
- Is page_correct NA for corrected_page not NA?
```{r}
df10 %>% filter(is.na(page_correct) & !is.na(corrected_page))
```

- Is page_correct set to "Yes" and corrected_page not NA?
```{r}
df10 %>% filter(page_correct == "Yes" & !is.na(corrected_page))
```
Correct this manually
```{r}
df11 <- df10 %>% 
  mutate(page_correct = ifelse(page_correct == "Yes" & !is.na(corrected_page), "No", page_correct))
```

# Save cleaned data
```{r}
write.csv(df11,"../data/processed/cleaned_data.csv")
```

