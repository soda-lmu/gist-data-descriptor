---
title: "gs2_expert_annotation_template"
author: "Anna Steinberg and Laia Domenech Burin"
date: "`r Sys.Date()`"
output: distill::distill_article
---

## Goal of the script: Set up expert annotation template and transform reports requiring expert adjudication to template

### Read input data and packages

```{r}
library(tidyverse)
library(openxlsx)

exp_demand_data <- read.csv('../../data/processed/gold_standard/data_for_expert_annotation_w_lay_annotations.csv')

coding_organisation <- read.xlsx('../../data/processed/double_coding.xlsx', sheet = 'Tabelle3')
```

### Filter files that require expert revision 

```{r}
exp_demand_data <- exp_demand_data %>% group_by(report_name) %>% filter(document_expert_requested_by_at_least_one_annotator == "Yes" | any(row_expert_requested_by_at_least_one_annotator_or_disagreement == "Yes")) %>% ungroup()
```

## Expert experiment (not needed anymore)

Template has 2 versions:

1. Version is the same as the version provided to the lay annotators
2. Version includes values and units provided by lay annotators

Split the data into two versions of the template for experiment
```{r}
# Reformat the data for hidden rows
hidden_data <- coding_organisation %>%
  select(hidden1, hidden2, report) %>%
  mutate(template_type = "hidden") %>%
  rename(expert1 = hidden1, expert2 = hidden2, report_name = report)

# Reformat the data for visible rows
visible_data <- coding_organisation %>%
  select(visible1, visible2, report) %>%
  mutate(template_type = "visible") %>%
  rename(expert1 = visible1, expert2 = visible2, report_name = report)

# Combine hidden and visible data
combined_data <- rbind(hidden_data, visible_data)

set.seed(1)

random_sample_numbers <- sample(0:9999, nrow(combined_data), replace = FALSE)

combined_data <- combined_data %>% mutate(folder_name = paste0(expert1, '_and_', expert2),
                                          new_report_name = str_remove(paste0(random_sample_numbers, '_', report_name), '.pdf'))
```

### Create functions to fill, format and save the templates

```{r}
# Template header is the same for both templates
fill_template_header <- function(template_header, 
                                 exp_demand_data){
  
  colnames(template_header) <- 'File data'
  
  # When a row was added only by one annotator, document_comment_annotator_x contains cells with NA
  # We need to set the value of document_comment_x to the non-NA value if available
  
  doc_comment_1 <- if (length(exp_demand_data %>% distinct(document_comment_1) %>% pull(document_comment_1)) > 1) {
    exp_demand_data %>% distinct(document_comment_1) %>% filter(!is.na(document_comment_1)) %>% pull(document_comment_1)
  } else {
    exp_demand_data %>% distinct(document_comment_1) %>% pull(document_comment_1)
  }
  
  doc_comment_2 <- if (length(exp_demand_data %>% distinct(document_comment_2) %>% pull(document_comment_2)) > 1) {
    exp_demand_data %>% distinct(document_comment_2) %>% filter(!is.na(document_comment_2)) %>% pull(document_comment_2)
  } else {
    exp_demand_data %>% distinct(document_comment_2) %>% pull(document_comment_2)
  }
  
  Extra <- c(
    unique(exp_demand_data$report_name),
    doc_comment_1,
    doc_comment_2,
    unique(exp_demand_data$document_expert_requested_by_at_least_one_annotator)
  )
  
  # Extend or trim 'Extra' to match the length of 'template_header'
  Extra_padded <- if (length(Extra) < nrow(template_header)) {
    c(Extra, rep(NA, nrow(template_header) - length(Extra)))
  } 
  
  else {
    Extra[1:nrow(template_header)]
  }
  
  # Create the result tibble with the header and the padded 'Extra' column
  result <- tibble(
    ' ' = template_header[[1]],
    '  ' = Extra_padded
  )
  return(result)
}
```

```{r}
# Template table differs between template 1 and 2
fill_template_table <- function(exp_demand_data, 
                                template_table,
                                template_number){
  
  if (template_number == 2){
    
    exp_demand_data_columns <- exp_demand_data %>% select(ID, 
                                                      page_used,
                                                      starts_with('llm'), 
                                                      contains('_1'),
                                                      contains('_2'),
                                                      row_expert_requested_by_at_least_one_annotator_or_disagreement)
    
    template_columns <- template_table %>%
      select('LLM Year',
             'LLM Scope',
             'Value: Who is right?':'Value Reasoning (select if necessary, if multiple apply choose first)',
             'Unit: Who is right?':'Unit reasoning  (select if necessary, if multiple apply choose first)',
             'Page corrected (fill in if necessary)',
             'Expert comment')
  } else {
    
    exp_demand_data_columns <- exp_demand_data %>% select(ID, 
                                                      page_used,
                                                      starts_with('llm'),
                                              row_expert_requested_by_at_least_one_annotator_or_disagreement,
                                              comment_1,
                                              comment_2)
    
    template_columns <- template_table %>% 
      select(c('LLM Year', 'LLM Scope'))

  }
  
  
  fill_template_table <- template_columns %>% left_join(exp_demand_data_columns, 
                                                         by = c('LLM Year' = 'llm_year',
                                                                'LLM Scope' = 'llm_scope'))
  return(fill_template_table)
}
```

```{r}
rename_and_organize_columns <- function(table, 
                                        template_number){
  
  if (template_number == 2){
    
    table <- table %>%
      select(
        'ID',
        'Page used' = 'page_used',
        'LLM Year',
        'LLM Scope',
        'LLM Value' = 'llm_value',
        'LLM Unit' = 'llm_unit',
        row_expert_requested_by_at_least_one_annotator_or_disagreement,
        'Value correct (Yes/No) Ann 1' = 'value_correct_1',
        'Value corrected Ann 1' = 'corrected_value_1',
        'Corrected page Ann 1' = 'corrected_page_1',
        'Value correct (Yes/No) Ann 2' = 'value_correct_2',
        'Value corrected Ann 2' = 'corrected_value_2',
        'Corrected page Ann 2' = 'corrected_page_2',
        'Value: Who is right?',
        'Value corrected (fill in if necessary)',
        'Value Reasoning (select if necessary, if multiple apply choose first)',
        'Unit correct (Yes/No) Ann 1' = 'unit_correct_1',
        'Unit corrected Ann 1' = 'corrected_unit_1',
        'Unit correct (Yes/No) Ann 2' = 'unit_correct_2', 
        'Unit corrected Ann 2' = 'corrected_unit_2',
        'Unit: Who is right?',
        'Unit corrected (fill in if necessary)',
        'Unit reasoning  (select if necessary, if multiple apply choose first)',
        'Comment Ann1' = 'comment_1',
        'Comment Ann2'= 'comment_2',
        'Page corrected (fill in if necessary)',
        'Expert comment')

  } else {
    
    table <- table %>%
      select(
        'ID',
        'Page used' = 'page_used',
        'LLM Year',
        'LLM Scope',
        'LLM Value' = 'llm_value',
        'LLM Unit' = 'llm_unit', 
        row_expert_requested_by_at_least_one_annotator_or_disagreement,
        'Comment Ann1' = 'comment_1',
        'Comment Ann2'= 'comment_2'
        )

  }
  
  return(table)
  
}
```

```{r}
write_templates_per_doc <- function(template_path, 
                                    filled_header,
                                    filled_table,
                                    doc_name,
                                    template_number){
  
  if (template_number == 2){
    
      wb <- loadWorkbook(template_path)

      writeData(wb, sheet = "Annotation", 
                    x = filled_header, 
                    startCol = 1, startRow = 1, 
                    colNames = TRUE, rowNames = FALSE)
          
      writeData(wb, sheet = "Annotation",
                x = filled_table,
                startCol = 1, startRow = 12,
                colNames = TRUE, rowNames = FALSE)
      
      doc_export_data <- combined_data %>% filter(template_type == 'visible' & report_name == doc_name)
      
      folder_path <- paste0("../../data/templates/filled_company_templates/", doc_export_data$folder_name)
      
      if (!dir.exists(folder_path)) {
        dir.create(folder_path, recursive = TRUE)
      }
        # Save the workbook with updates
      saveWorkbook(wb, file = paste0("../../data/templates/filled_company_templates/",doc_export_data$folder_name, "/", doc_export_data$new_report_name,".xlsx"), overwrite = TRUE)

  }
  
  else {
    
      wb <- loadWorkbook(template_path)
    
      writeData(wb, sheet = "Annotation", 
                    x = filled_header, 
                    startCol = 1, startRow = 1, 
                    colNames = TRUE, rowNames = FALSE)
          
      writeData(wb, sheet = "Annotation",
                x = filled_table,
                startCol = 1, startRow = 12,
                colNames = TRUE, rowNames = FALSE)
      
      doc_export_data <- combined_data %>% filter(template_type == 'hidden' & report_name == doc_name)
      
      folder_path <- paste0("../../data/templates/filled_company_templates/", doc_export_data$folder_name)
      
        if (!dir.exists(folder_path)) {
          dir.create(folder_path, recursive = TRUE)
          }


      # Save the workbook with updates
      saveWorkbook(wb, file = paste0("../../data/templates/filled_company_templates/",doc_export_data$folder_name,"/", doc_export_data$new_report_name,".xlsx"), overwrite = TRUE)

  }
  
}

```

### Loop over documents
```{r}
# Combined function to fill and write the two templates per document
fill_and_write_templates <- function(document_name, exp_demand_data, template1_path, template2_path) {
  
  # Load the data of the document
  document_data <- exp_demand_data %>% filter(report_name == document_name)
  
  # Load the templates 1 and 2 and save header and table separately
  template1_header <- readxl::read_excel(template1_path, sheet = 1, col_names = FALSE, n_max = 9)
  template1_table <- readxl::read_excel(template1_path, sheet = 1, skip = 11)
  template2_header <- readxl::read_excel(template2_path, sheet = 1, col_names = FALSE, n_max = 4)
  template2_table <- readxl::read_excel(template2_path, sheet = 1, skip = 11)
  
  # Fill template headers
  filled_header1 <- fill_template_header(template_header = template1_header,
                                      exp_demand_data = document_data)

  filled_header2 <- fill_template_header(template_header = template2_header,
                                        exp_demand_data = document_data)
  
  # Fill template tables
  filled_template_table1 <- fill_template_table(exp_demand_data = document_data,
                                               template_table = template1_table,
                                               template_number = 1)
  filled_template_table2 <- fill_template_table(exp_demand_data = document_data,
                                               template_table = template2_table,
                                               template_number = 2)
  # Rename and organize
  filled_template_table1 <- rename_and_organize_columns(filled_template_table1, 1)
  filled_template_table2 <- rename_and_organize_columns(filled_template_table2, 2)
  
  # Save
  write_templates_per_doc(template_path = template1_path,
                          filled_header = filled_header1,
                          filled_table = filled_template_table1,
                          doc_name = document_name,
                          template_number = 1)
  
  write_templates_per_doc(template_path = template2_path,
                          filled_header = filled_header2,
                          filled_table = filled_template_table2,
                          doc_name = document_name,
                          template_number = 2)
}
```

### Run for all documents
```{r}
# Set paths to templates
template1_path <- '../../data/templates/expert_annotation_setup_1.xlsx'
template2_path <- '../../data/templates/expert_annotation_setup_2.xlsx' 

# Apply to all (sample) documents
documents <- unique(exp_demand_data$report_name)
map(documents, fill_and_write_templates, exp_demand_data = exp_demand_data, template1_path = template1_path, template2_path = template2_path)
```

```{r}
write.xlsx(combined_data, '../../data/templates/filled_templates_main.xlsx')
```

## Without Expert Experiment


```{r}
# Reformat the data
set1 <- coding_organisation %>%
  select(hidden1, hidden2, report) %>%
  rename(expert1 = hidden1, expert2 = hidden2, report_name = report)

# Reformat the data
set2 <- coding_organisation %>%
  select(visible1, visible2, report) %>%
  rename(expert1 = visible1, expert2 = visible2, report_name = report)

# Combine hidden and visible data
combined_data <- rbind(set1, set2) %>% mutate(template_type = "visible") # no experiment

set.seed(1)

random_sample_numbers <- sample(0:9999, nrow(combined_data), replace = FALSE)

combined_data <- combined_data %>% mutate(folder_name = paste0(expert1, '_and_', expert2),
                                          new_report_name = str_remove(paste0(random_sample_numbers, '_', report_name), '.pdf'))

# rename folder_name of "maurice_and_andreas" to "andreas_and_maurice"
combined_data$folder_name[combined_data$folder_name == "maurice_and_andreas"] <- "andreas_and_maurice"
```

```{r}
write.xlsx(combined_data, '../../data/templates/filled_templates_main.xlsx')
```

```{r}
# Template header is the same for both templates
fill_template_header <- function(template_header, 
                                 exp_demand_data){
  
  colnames(template_header) <- 'File data'
  
  # When a row was added only by one annotator, document_comment_annotator_x contains cells with NA
  # We need to set the value of document_comment_x to the non-NA value if available
  
  doc_comment_1 <- if (length(exp_demand_data %>% distinct(document_comment_1) %>% pull(document_comment_1)) > 1) {
    exp_demand_data %>% distinct(document_comment_1) %>% filter(!is.na(document_comment_1)) %>% pull(document_comment_1)
  } else {
    exp_demand_data %>% distinct(document_comment_1) %>% pull(document_comment_1)
  }
  
  doc_comment_2 <- if (length(exp_demand_data %>% distinct(document_comment_2) %>% pull(document_comment_2)) > 1) {
    exp_demand_data %>% distinct(document_comment_2) %>% filter(!is.na(document_comment_2)) %>% pull(document_comment_2)
  } else {
    exp_demand_data %>% distinct(document_comment_2) %>% pull(document_comment_2)
  }
  
  Extra <- c(
    unique(exp_demand_data$report_name),
    doc_comment_1,
    doc_comment_2,
    unique(exp_demand_data$document_expert_requested_by_at_least_one_annotator)
  )
  
  # Extend or trim 'Extra' to match the length of 'template_header'
  Extra_padded <- if (length(Extra) < nrow(template_header)) {
    c(Extra, rep(NA, nrow(template_header) - length(Extra)))
  } 
  
  else {
    Extra[1:nrow(template_header)]
  }
  
  # Create the result tibble with the header and the padded 'Extra' column
  result <- tibble(
    ' ' = template_header[[1]],
    '  ' = Extra_padded
  )
  return(result)
}
```

Reusing function from before
```{r}
# Template table differs between template 1 and 2
fill_template_table <- function(exp_demand_data, 
                                template_table,
                                template_number){
  
  if (template_number == 2){
    
    exp_demand_data_columns <- exp_demand_data %>% select(ID, 
                                                      page_used,
                                                      starts_with('llm'), 
                                                      contains('_1'),
                                                      contains('_2'),
                                                      row_expert_requested_by_at_least_one_annotator_or_disagreement)
    
    template_columns <- template_table %>%
      select('LLM Year',
             'LLM Scope',
             'Value: Who is right?':'Value Reasoning (select if necessary, if multiple apply choose first)',
             'Unit: Who is right?':'Unit reasoning  (select if necessary, if multiple apply choose first)',
             'Page corrected (fill in if necessary)',
             'Expert comment')
  } else {
    
    exp_demand_data_columns <- exp_demand_data %>% select(ID, 
                                                      page_used,
                                                      starts_with('llm'),
                                              row_expert_requested_by_at_least_one_annotator_or_disagreement,
                                              comment_1,
                                              comment_2)
    
    template_columns <- template_table %>% 
      select(c('LLM Year', 'LLM Scope'))

  }
  
  fill_template_table <- template_columns %>% full_join(exp_demand_data_columns, 
                                                         by = c('LLM Year' = 'llm_year',
                                                                'LLM Scope' = 'llm_scope'))
  
  fill_template_table <- fill_template_table %>% filter(!is.na(ID))
  return(fill_template_table)
}
```
Reusing function from before
```{r}
rename_and_organize_columns <- function(table, 
                                        template_number){
  
  if (template_number == 2){
    
    table <- table %>%
      select(
        'ID',
        'Page used' = 'page_used',
        'LLM Year',
        'LLM Scope',
        'LLM Value' = 'llm_value',
        'LLM Unit' = 'llm_unit',
        row_expert_requested_by_at_least_one_annotator_or_disagreement,
        'Value correct (Yes/No) Ann 1' = 'value_correct_1',
        'Value corrected Ann 1' = 'corrected_value_1',
        'Corrected page Ann 1' = 'corrected_page_1',
        'Value correct (Yes/No) Ann 2' = 'value_correct_2',
        'Value corrected Ann 2' = 'corrected_value_2',
        'Corrected page Ann 2' = 'corrected_page_2',
        'Value: Who is right?',
        'Value corrected (fill in if necessary)',
        'Value Reasoning (select if necessary, if multiple apply choose first)',
        'Unit correct (Yes/No) Ann 1' = 'unit_correct_1',
        'Unit corrected Ann 1' = 'corrected_unit_1',
        'Unit correct (Yes/No) Ann 2' = 'unit_correct_2', 
        'Unit corrected Ann 2' = 'corrected_unit_2',
        'Unit: Who is right?',
        'Unit corrected (fill in if necessary)',
        'Unit reasoning  (select if necessary, if multiple apply choose first)',
        'Comment Ann1' = 'comment_1',
        'Comment Ann2'= 'comment_2',
        'Page corrected (fill in if necessary)',
        'Expert comment')

  } else {
    
    table <- table %>%
      select(
        'ID',
        'Page used' = 'page_used',
        'LLM Year',
        'LLM Scope',
        'LLM Value' = 'llm_value',
        'LLM Unit' = 'llm_unit', 
        row_expert_requested_by_at_least_one_annotator_or_disagreement,
        'Comment Ann1' = 'comment_1',
        'Comment Ann2'= 'comment_2'
        )

  }

  return(table)
  
}
```

```{r}
write_template2_per_doc <- function(template_path, 
                                    filled_header,
                                    filled_table,
                                    doc_name){
  
    wb <- loadWorkbook(template_path)

    writeData(wb, sheet = "Annotation", 
                  x = filled_header, 
                  startCol = 1, startRow = 1, 
                  colNames = TRUE, rowNames = FALSE)
        
    writeData(wb, sheet = "Annotation",
              x = filled_table,
              startCol = 1, startRow = 12,
              colNames = TRUE, rowNames = FALSE)
    
    doc_export_data <- combined_data %>% filter(report_name == doc_name)
    
    folder_paths <- paste0("../../data/templates/filled_company_templates/", doc_export_data$folder_name)

    for (i in 1:length(folder_paths)) {
      if (!dir.exists(folder_paths[i])) {
        dir.create(folder_paths[i], recursive = TRUE)
      }
      # Save the workbook with updates
      saveWorkbook(wb, file = paste0(folder_paths[i], "/", doc_export_data$new_report_name[i],".xlsx"), overwrite = TRUE)
    }
}
```

```{r}
# Combined function to fill and write a template per document
fill_and_write_template <- function(document_name, exp_demand_data, template2_path) {
  
  # Load the data of the document
  document_data <- exp_demand_data %>% filter(report_name == document_name)
  
  # Load the templates 1 and 2 and save header and table separately
  template2_header <- readxl::read_excel(template2_path, sheet = 1, col_names = FALSE, n_max = 4)
  template2_table <- readxl::read_excel(template2_path, sheet = 1, skip = 11)
  
  # Fill template headers
  filled_header2 <- fill_template_header(template_header = template2_header,
                                        exp_demand_data = document_data)

    # Fill template tables
  filled_template_table2 <- fill_template_table(exp_demand_data = document_data,
                                               template_table = template2_table,
                                               template_number = 2)
  # Rename and organize
  filled_template_table2 <- rename_and_organize_columns(filled_template_table2, 2)
  
  # Save
  write_template2_per_doc(template_path = template2_path,
                          filled_header = filled_header2,
                          filled_table = filled_template_table2,
                          doc_name = document_name)
}
```

Delete later
```{r}
template2_table <- readxl::read_excel(template2_path, sheet = 1, skip = 11)

filled_template_table <- fill_template_table(exp_demand_data = exp_demand_data %>% filter(report_name == "comerica inc_2019_report.pdf"),
                                               template_table = template2_table,
                                               template_number = 2)

rename_and_organize_columns(filled_template_table, 2)
```
### Run for all documents
```{r}
# Set path to template
template2_path <- '../../data/templates/expert_annotation_setup_2.xlsx' 

# Apply to all (sample) documents
documents <- unique(exp_demand_data$report_name)
map(documents, fill_and_write_template, exp_demand_data = exp_demand_data, template2_path = template2_path)
```
### Corrections
Correct template for reports where ID contains rows with "x"
```{r}
reports_for_correction <- exp_demand_data %>% filter(grepl("x_", ID)) %>% distinct(report_name) %>% pull(report_name)

reports_for_correction
```

```{r}
# Set path to template
template2_path <- '../../data/templates/expert_annotation_setup_2.xlsx' 

map(reports_for_correction, fill_and_write_template, exp_demand_data = exp_demand_data, template2_path = template2_path)
```
